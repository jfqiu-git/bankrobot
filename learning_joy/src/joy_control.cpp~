#include <ros/ros.h>
#include <geometry_msgs/Twist.h>
#include <sensor_msgs/Joy.h>

double vel_linear = 0, vel_angular = 0;
int linear_, angular_;
int linear_up_, linear_down_, angular_up_, angular_down_;

float scale_l_ = 1.0f; 
float scale_r_ = 1.0f;

void joyCallback(const sensor_msgs::Joy::ConstPtr& joy)
{
	if (joy->buttons[linear_up_]) scale_l_ += 1.0;
	if (joy->buttons[linear_down_] && scale_l_ >= 1.0) scale_l_ -= 1.0;
	if (joy->buttons[angular_up_]) scale_r_ += 1.0;
	if (joy->buttons[angular_down_] && scale_r_ >= 1.0) scale_r_ -= 1.0;

	vel_linear = joy->axes[linear_];
	vel_angular = joy->axes[angular_];
}

int main(int argc, char** argv)
{
	ros::init(argc, argv, "joycontrol");
	ros::NodeHandle nh_;

  	nh_.param("axis_linear", linear_, linear_);
  	nh_.param("axis_angular", angular_, angular_);
  	nh_.param("up_linear", linear_up_, linear_up_);
  	nh_.param("down_linear", linear_down_, linear_down_);
  	nh_.param("up_angular", angular_up_, angular_up_);
  	nh_.param("down_angular", angular_down_, angular_down_);

  	ros::Publisher vel_pub_ = nh_.advertise<geometry_msgs::Twist>("turtle1/cmd_vel", 10);
  	ros::Subscriber joy_sub_ = nh_.subscribe<sensor_msgs::Joy>("joy", 10, joyCallback);

	ros::Rate r(10);
	while (ros::ok())
	{
		ros::spinOnce();
		
  		geometry_msgs::Twist vel;
	 	vel.linear.x = scale_l_ * vel_linear;
	  	vel.angular.z = scale_r_ * vel_angular;
	  	vel_pub_.publish(vel);
		ROS_INFO("JOY -- linear: %f*[%f] angular: %f*[%f]", scale_l_, vel_linear, scale_r_, vel_angular);
	
		r.sleep();
	}

	ros::shutdown();
}
