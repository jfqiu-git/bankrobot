#include <ros/ros.h>

#include <stdio.h>
#include <iostream>
#include <depth_to_laser.h>
#include <depth_traits.h>

#include <sensor_msgs/Image.h>
#include <sensor_msgs/CameraInfo.h>
#include <sensor_msgs/LaserScan.h>
#include <image_transport/image_transport.h>

#include <cv_bridge/cv_bridge.h>
#include <opencv2/core/core.hpp>
#include <opencv2/highgui/highgui.hpp>  

/*
    y                  
    ^   .z           .z
    |  .            .
    | .            .
<----             ----->
x                      x
  (PCL)          (HOKUYO)
*/

//laserscan 
double PI = 3.141592653;
double translation_x_, translation_z_;

//subscribe 
Params param;
bool camera_info_ready = false;

//publisher
ros::Publisher kinectscan_pub;

// camera info subscribe
void infoCallback(const sensor_msgs::CameraInfoConstPtr& info_msg)
{
	if (!camera_info_ready)
	{
		try
		{
			// (f, c_u, c_v, scan_height, translation_x, translation_z)
			param.setParams(info_msg->K[0], info_msg->K[2], info_msg->K[5], info_msg->height, translation_x_, translation_z_);
			camera_info_ready = true;
		}
		
		catch (cv_bridge::Exception& e)
		{
			ROS_ERROR("Could not get camera info.");
		}
	}
}

// depth image subscribe
void depthCallback(const sensor_msgs::ImageConstPtr& depth_msg)
{
	if (camera_info_ready) 
	{
		try
		{	
			// depth_to_laser
			sensor_msgs::LaserScanPtr scan_msg(new sensor_msgs::LaserScan());
			depth_to_laser::depth2laser(depth_msg, scan_msg, param);
			kinectscan_pub.publish(scan_msg);
		}
		catch (cv_bridge::Exception& e)
		{
			ROS_ERROR("Could not convert from '%s' to '16UC1'.", depth_msg->encoding.c_str());
		}
	}
}

// kinect2/hd/image_color_rect  - (1920,1080) - rectified  
// kinect2/qhd/image_color_rect - (960,540)   - rectified
// kinect2/sd/image_color_rect  - (512,424)   - distorted
int main(int argc, char** argv)
{
	//init
    	ros::init(argc, argv, "kinectscan");
    	ros::NodeHandle nh;

	//params
  	nh.param("translation_x", translation_x_, translation_x_);
  	nh.param("translation_z", translation_z_, translation_z_);

	//registration
	image_transport::ImageTransport it_depth(nh);
	image_transport::Subscriber sub_depth = it_depth.subscribe("/kinect2/qhd/image_depth_rect", 1, depthCallback);
	ros::Subscriber caminfo_sub = nh.subscribe<sensor_msgs::CameraInfo>("/kinect2/qhd/camera_info", 1, infoCallback);
    	kinectscan_pub = nh.advertise<sensor_msgs::LaserScan>("/kinectscan", 1);

	//loop
	ros::spin();
	ros::shutdown();

	return 0;
}











